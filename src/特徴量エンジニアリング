#===特徴量エンジニアリング===
cols = df.columns
df_feat = df.copy() # コピー作成

# ラグ
lags = [1, 24, 168]  # 24h, 168h
for lag in lags:
    for col in cols:
        df_feat[f'{col}_lag_{lag}'] = df_feat[col].shift(lag)

# 差分
shifts = [24, 168]  # 24h, 168h
for shift in shifts:
    for col in cols:
        df_feat[f'{col}_diff_{shift}'] = df_feat[col] - df_feat[col].shift(shift)

# ローリング
windows = [24, 168]  # 24h, 168h
for window in windows:
    for col in cols:
        roll = df_feat[col].rolling(window=window, closed='left')
        df_feat[f'{col}_roll_mean_{window}'] = roll.mean()
        df_feat[f'{col}_roll_std_{window}']  = roll.std()

# 指数平滑
spans = [24, 168]
for span in spans:
  for col in cols:
    df_feat[f"{col}_ewm{span}"] = df[col].ewm(span=span, adjust=False).mean()

# 高相関の組み合わせ
df_feat['HUFL_OT_inter']  = df_feat['HUFL'] * df_feat['OT']
df_feat['MUFL_OT_inter']  = df_feat['MUFL'] * df_feat['OT']
df_feat['HUFL_times_MUFL'] = df_feat['HUFL'] * df_feat['MUFL']


# 周期性考慮
df_feat['sin_24h'] = np.sin(2 * np.pi * df_feat.index.hour / 24)
df_feat['cos_24h'] = np.cos(2 * np.pi * df_feat.index.hour / 24)

# 欠損値処理
columns = df_feat.columns

#定常性確認(特徴量エンジニアリング後)
columns = df_feat.columns.difference(['OT','sin_24h','cos_24h'])
TEST_SIZE = 24
train_df = df_feat.iloc[:-TEST_SIZE] # 検証データの隔離
non_stationary_cols = []


# 非定常カラムの特定
for col in columns:
    series = train_df[col]
    series = series.dropna()
    kpss_stat, kpss_p, *_ = kpss(series, regression='ct')
    if kpss_p > 0.05:
        print(f'定常 {col}: KPSS p={kpss_p}')
    else:
        print(f'非定常 {col}: KPSS p={kpss_p}')
        non_stationary_cols.append(col)

# 非定常カラムのみ差分を取る
for col in non_stationary_cols:
    df_feat[col] = df_feat[col].diff()

df_feat = df_feat.dropna()

# 定常性再確認
for col in columns:
    series = df_feat[col]
    series = series.dropna()
    kpss_stat, kpss_p, *_ = kpss(series, regression='ct')
    if kpss_p > 0.05:
       print(f'定常 {col}: KPSS p={kpss_p}')
    else:
       print(f'非定常 {col}: KPSS p={kpss_p}')
