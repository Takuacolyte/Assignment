#===特徴量エンジニアリング===
cols = df.columns
df_feat = df.copy() # コピー作成

# ラグ
lags = [1, 24, 168]  # 24h, 168h
for lag in lags:
    for col in cols:
        df_feat[f'{col}_lag_{lag}'] = df_feat[col].shift(lag)

# 差分
shifts = [24, 168]  # 24h, 168h
for shift in shifts:
    for col in cols:
        df_feat[f'{col}_diff_{shift}'] = df_feat[col] - df_feat[col].shift(shift)

# ローリング
windows = [24, 168]  # 24h, 168h
for window in windows:
    for col in cols:
        roll = df_feat[col].rolling(window=window, closed='left')
        df_feat[f'{col}_roll_mean_{window}'] = roll.mean()
        df_feat[f'{col}_roll_std_{window}']  = roll.std()
# 指数平滑
spans = [24, 168]
for span in spans:
  for col in cols:
    df_feat[f"{col}_ewm{span}"] = df[col].ewm(span=span, adjust=False).mean()

# 高相関の組み合わせ
df_feat['HUFL_OT_inter']  = df_feat['HUFL'] * df_feat['OT']
df_feat['MUFL_OT_inter']  = df_feat['MUFL'] * df_feat['OT']
df_feat['HUFL_times_MUFL'] = df_feat['HUFL'] * df_feat['MUFL']


# 周期性考慮
df_feat['sin_24h'] = np.sin(2 * np.pi * df_feat.index.hour / 24)
df_feat['cos_24h'] = np.cos(2 * np.pi * df_feat.index.hour / 24)

# 欠損値処理
columns = df_feat.columns
